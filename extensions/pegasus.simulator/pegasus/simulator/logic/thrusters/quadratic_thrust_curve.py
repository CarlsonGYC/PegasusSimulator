"""
| File: quadratic_thrust_curve.py
| Author: Marcelo Jacinto (marcelo.jacinto@tecnico.ulisboa.pt)
| Descriptio: File that implements a quadratic thrust curve for rotors
| License: BSD-3-Clause. Copyright (c) 2023, Marcelo Jacinto. All rights reserved.
"""
import numpy as np
from pegasus.simulator.logic.state import State
from pegasus.simulator.logic.thrusters.thrust_curve import ThrustCurve
from pegasus.simulator.logic.utils.first_order_filter import FirstOrderFilter

class QuadraticThrustCurve(ThrustCurve):
    """Class that implements the dynamics of rotors that can be described by a quadratic thrust curve
    """
    def __init__(self, config={}):
        """_summary_

        Args:
            config (dict): A Dictionary that contains all the parameters for configuring the QuadraticThrustCurve - it can be empty or only have some of the parameters used by the QuadraticThrustCurve.
        
        Examples:
            The dictionary default parameters are

            >>> {"num_rotors": 4,
            >>>  "rotor_constant": [5.84e-6, 5.84e-6, 5.84e-6, 5.84e-6],
            >>>  "moment_constant": [0.06, 0.06, 0.06, 0.06],
            >>>  "rotor_drag_coefficient": [1.75e-4, 1.75e-4, 1.75e-4, 1.75e-4],
            >>>  "rolling_moment_coefficient": [1e-6, 1e-6, 1e-6, 1e-6],
            >>>  "rot_dir": [1, 1, -1, -1],
            >>>  "min_rotor_velocity": [0, 0, 0, 0],                      # rad/s
            >>>  "max_rotor_velocity": [1100, 1100, 1100, 1100],          # rad/s
            >>>  "time_constant_up": 0.0125,                              # s
            >>>  "time_constant_down": 0.025,                             # s
            >>>  "reversible": False                                      # boolean
            >>> }
        """

        # Get the total number of rotors to simulate
        self._num_rotors = config.get("num_rotors", 4)

        # The rotor constant used for computing the total thrust produced by the rotor: T = rotor_constant * omega * |omega|
        self._rotor_constant = config.get("rotor_constant", [8.54858e-6, 8.54858e-6, 8.54858e-6, 8.54858e-6])
        assert len(self._rotor_constant) == self._num_rotors
        
        # The rotor constant used for computing the drag torque generated by the rotor
        self._moment_constant = config.get("moment_constant", [0.06, 0.06, 0.06, 0.06])
        assert len(self._moment_constant) == self._num_rotors
        
        # The rotor constant used for computing the air drag force generated by the rotor
        self._rotor_drag_coefficient = config.get("rotor_drag_coefficient", [1.75e-4, 1.75e-4, 1.75e-4, 1.75e-4])
        assert len(self._rotor_drag_coefficient) == self._num_rotors
        
        # The rotor constant used for computing the rolling moment (- \omega * \mu_1 * V_A^{\perp})
        self._rolling_moment_coefficient = config.get("rolling_moment_coefficient", [1e-6, 1e-6, 1e-6, 1e-6])
        assert len(self._rolling_moment_coefficient) == self._num_rotors

        # Save the rotor direction of rotation
        self._rot_dir = config.get("rot_dir", [1, 1, -1, -1])
        assert len(self._rot_dir) == self._num_rotors

        # Values for the minimum and maximum rotor velocity in rad/s
        self.min_rotor_velocity = config.get("min_rotor_velocity", [0, 0, 0, 0])
        assert len(self.min_rotor_velocity) == self._num_rotors

        self.max_rotor_velocity = config.get("max_rotor_velocity", [1100, 1100, 1100, 1100])
        assert len(self.max_rotor_velocity) == self._num_rotors
        
        # Time constants for the rotor to go up and down
        self._time_constant_up = config.get("time_constant_up", 0.0125)
        self._time_constant_down = config.get("time_constant_down", 0.025)
        assert self._time_constant_up > 0 and self._time_constant_down > 0
        
        # Boolean that indicates if the rotor is reversible
        self._reversible = config.get("reversible", False)

        # The actual speed references to apply to the vehicle rotor joints
        self._input_reference = [0.0 for i in range(self._num_rotors)]
        
        # The rotor velocity first order filter
        self._rotor_velocity_filter = [FirstOrderFilter(self._time_constant_up, self._time_constant_down, self._input_reference[i]) for i in range(self._num_rotors)]

        # The actual velocity that each rotor is spinning at
        self._velocity = [0.0 for i in range(self._num_rotors)]

        # The actual force that each rotor is generating
        self._force = [0.0 for i in range(self._num_rotors)]

        # The actual drag torque that is generated on the body frame of the vehicle
        self._drag_torque = 0.0

    def set_input_reference(self, input_reference):
        """
        Receives as input a list of target angular velocities of each rotor in rad/s
        """

        # The target angular velocity of the rotor
        self._input_reference = input_reference

    def update(self, state: State, dt: float):
        """
        Note: the state and dt variables are not used in this implementation, but left
        to add support to other rotor models where the total thrust is dependent on
        states such as vehicle linear velocity

        Args:
            state (State): The current state of the vehicle.
            dt (float): The time elapsed between the previous and current function calls (s).
        """
        # Convert the input reference to numpy arrays for easier manipulation
        force = np.array(self._force)
        rot_dir = np.array(self._rot_dir)
        velocity = np.array(self._velocity)
        rotor_constant = np.array(self._rotor_constant)
        moment_constant = np.array(self._moment_constant)
        input_reference = np.array(self._input_reference)
        min_rotor_velocity = np.array(self.min_rotor_velocity)
        max_rotor_velocity = np.array(self.max_rotor_velocity)
        rotor_drag_coefficient = np.array(self._rotor_drag_coefficient)
        rolling_moment_coefficient = np.array(self._rolling_moment_coefficient)
        
        # Apply clipping of the input reference
        input_reference = np.clip(input_reference, min_rotor_velocity, max_rotor_velocity)

        # Compute the actual force to apply to the rotors
        for i in range(self._num_rotors):
            # Set the actual velocity that each rotor is spinning at (first order process model)
            velocity[i] = self._rotor_velocity_filter[i].update(input_reference[i], dt)

        # Set the force using a quadratic thrust curve
        force = rotor_constant * velocity * np.abs(velocity)
        
        if not self._reversible:
            # Not allowed to have negative thrust
            force = np.abs(force)
        
        """
        ----------------- Scaling Down the Force -----------------
        Scale down the force linearly with forward velocity.
        The rotor will produce zero thrust when the forward velocity is equal 25 m/s (experencial value)
        """
        # Compute the the relative wind velocity
        wind_velocity = np.array([0.0, 0.0, 0.0]) # TODO: Implement wind velocity
        relative_wind_velocity = state.linear_velocity - wind_velocity

        # Get the rotor axis (Z-axis) in the inertial frame
        rotor_axis = state.get_axis_vector(2)

        # Compute the velocity parallel and perpendicular to the rotor axis
        velocity_parallel_to_rotor_axis = np.dot(relative_wind_velocity, rotor_axis) * rotor_axis
        velocity_perpendicular_to_rotor_axis = relative_wind_velocity - velocity_parallel_to_rotor_axis

        # Scale down the force linearly with forward velocity
        scaling_factor = 1 - np.linalg.norm(velocity_parallel_to_rotor_axis) / 25.0 # No thrust when faster than 25 m/s
        force *= scaling_factor
        """
        ------------- End of Scaling Down the Force --------------
        """
        
        # Compute the global air drag force generated by the rotors
        air_drag = (-np.abs(velocity) * rotor_drag_coefficient)[:, np.newaxis] * velocity_perpendicular_to_rotor_axis
        
        # Compute the local drag torque
        self._drag_torque = np.sum(-moment_constant * force * rot_dir)
        
        # Compute the Rolling moment
        rolling_moment = np.sum(-np.abs(velocity) * rot_dir * rolling_moment_coefficient) * velocity_perpendicular_to_rotor_axis
        
        # Update all the internal variables
        self._force = force.tolist()
        self._velocity = velocity.tolist()
        self._input_reference = input_reference.tolist()

        # Return the forces and velocities on each rotor and total torque (drag torque and rolling moment) applied on the body frame
        return self._force, self._velocity, self._drag_torque, air_drag.tolist(), rolling_moment.tolist()

    @property
    def force(self):
        """The force to apply to each rotor of the vehicle at any given time instant

        Returns:
            list: A list of forces (in Newton N) to apply to each rotor of the vehicle (on its Z-axis) at any given time instant
        """
        return self._force

    @property
    def velocity(self):
        """The velocity at which each rotor of the vehicle should be rotating at any given time instant

        Returns:
            list: A list of angular velocities (in rad/s) of each rotor (about its Z-axis) at any given time instant
        """
        return self._velocity

    @property
    def drag_torque(self):
        """The total drag torque generated by the rotating propellers on the vehicle's body frame

        Returns:
            float: The total drag torque about the Z-axis in Nm
        """
        return self._drag_torque

    @property
    def rot_dir(self):
        """The direction of rotation of each rotor of the vehicle

        Returns:
            list(int): A list with the rotation direction of each rotor (1 is counter-clockwise and -1 for clockwise)
        """
        return self._rot_dir
